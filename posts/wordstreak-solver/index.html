<!DOCTYPE html>
<html lang="en-gb">
	<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="Jack Weatherilt">

<meta name="generator" content="Hugo 0.31.1" />
<title>Building a Word Streak Solver</title>
<link rel="shortcut icon" href="http://jackw.xyz/images/favicon.ico">
<link rel="stylesheet" href="http://jackw.xyz/css/style.css">
<link rel="stylesheet" href="http://jackw.xyz/css/highlight.css">



<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css">




<meta property="og:title" content="Building a Word Streak Solver" />
<meta property="og:description" content="Words with Friends&rsquo; Word Streak is a short but fast Scrabble-like game that I happen to be particularly bad at. The aim is similar to Words with Friends, where you try to build the highest value word from a set of tiles given, including the possibilites from multiplying your score in some way. It&rsquo;s fairly intuitive but also infuriating.
To end the embarrassment of losing, I decided to build a quick-and-dirty Python program to help me cheat." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://jackw.xyz/posts/wordstreak-solver/" />



<meta property="article:published_time" content="2018-03-18T18:00:00&#43;00:00"/>

<meta property="article:modified_time" content="2018-03-18T18:00:00&#43;00:00"/>













<meta itemprop="name" content="Building a Word Streak Solver">
<meta itemprop="description" content="Words with Friends&rsquo; Word Streak is a short but fast Scrabble-like game that I happen to be particularly bad at. The aim is similar to Words with Friends, where you try to build the highest value word from a set of tiles given, including the possibilites from multiplying your score in some way. It&rsquo;s fairly intuitive but also infuriating.
To end the embarrassment of losing, I decided to build a quick-and-dirty Python program to help me cheat.">


<meta itemprop="datePublished" content="2018-03-18T18:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2018-03-18T18:00:00&#43;00:00" />
<meta itemprop="wordCount" content="1273">



<meta itemprop="keywords" content="" />

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Building a Word Streak Solver"/>
<meta name="twitter:description" content="Words with Friends&rsquo; Word Streak is a short but fast Scrabble-like game that I happen to be particularly bad at. The aim is similar to Words with Friends, where you try to build the highest value word from a set of tiles given, including the possibilites from multiplying your score in some way. It&rsquo;s fairly intuitive but also infuriating.
To end the embarrassment of losing, I decided to build a quick-and-dirty Python program to help me cheat."/>


    </head>
<body>
    <nav class="main-nav">
	
		<a href='http://jackw.xyz/'> <span class="arrow">‚Üê</span>Home</a>
	

	

	
</nav>

    <section id="wrapper">
        
        
<article class="post">
    <header>
        <h1>Building a Word Streak Solver</h1>
        <h2 class="subtitle"></h2>
        <h2 class="headline">
        March 18, 2018
        <br>
        
        </h2>
    </header>
    <section id="post-body">
        

<p>Words with Friends&rsquo; Word Streak is a short but fast Scrabble-like game that I
happen to be particularly bad at. The aim is similar to Words with Friends,
where you try to build the highest value word from a set of tiles given,
including the possibilites from multiplying your score in some way. It&rsquo;s fairly
intuitive but also infuriating.</p>

<p><img src="/images/wordstreak.png" alt="screenshot" /></p>

<p>To end the embarrassment of losing, I decided to build a quick-and-dirty Python
program to help me cheat. Knowing about Scrabble solvers, I based my the code
directly off of <a href="https://pdfs.semanticscholar.org/da31/cb24574f7c881a5dbf008e52aac7048c9d9c.pdf">Appel and Jacobson&rsquo;s 1988
design</a>. The rest of this post will briefly describe the steps taken to build the solver.</p>

<h2 id="storing-a-dictionary">Storing a dictionary</h2>

<p>Words&rsquo; with Friends haven&rsquo;t openly published their dictionary, however, <a href="http://www.zyngawithfriends.com/wordswithfriends/support/WWF_Rulebook.html">they do
make
public</a> that it&rsquo;s based on the Enhanced North American Benchmark Lexicon (ENABLE) which is avaiable for download. A few words have been added to Words with Friends that aren&rsquo;t in ENABLE, such as &lsquo;texting&rsquo; and &lsquo;zen&rsquo;, but it will likely be a good enough dictionary for cheating.</p>

<p>To search the dictionary effectively, something other than an table-like data
structure will need to be used. Once a starting letter is chosen, all other
words that do not begin with the chosen letter need to be pruned; the pruning
needs to happen again for the second letter, third letter and so on. The
downside to this method is its complexity: each prune takes O(n), where n is the
number of words in the dictionary (so something around 11000). On top of this,
each path from letter to its surrounding letters would need to be tried. The
number of possible paths is O(16!), making this method undesirable.</p>

<p>A Trie, sometimes called a &lsquo;prefix tree&rsquo; is an ordered tree structure where each
edge is given a label corresponding to its distance from the start node and
position in a word of the dictionary. Not all node have values. The Trie can be
created from a dictionary by labelling each edge at distance i from the root
node with the i-th letter in a word in the dictionary. A word in our dictionary
&ldquo;corresponds a path from the root&rdquo;. So, if you follow a path from the root node
to some <em>valued</em> node, appending the label of each edge to a string as the edges
are passed over, the resulting string will be a word in the dictionary.</p>

<p>With a Trie, a starting letter can be chosen from the Word Streak grid, thereby
pruning our Trie to be the sub-tree resulting from following the relevant edge;
each of the neighbouring and unexplored letters can then be explored in the
tree. Every time a valued node is reached, a solution can be noted.</p>

<p><img src="/images/trie.png" alt="Trie" /></p>

<p>The Trie will contain many duplicate sub-paths, such as &lsquo;ideaology&rsquo; and
&lsquo;biology&rsquo; both following the different, but equivalent, &lsquo;ology&rsquo; edges. This
clearly leaves us with an unecessarily large data structure who&rsquo;s space could be
reduced. Where there are &lsquo;duplicate&rsquo; paths, these can be reused, and the result
structure is a directed, acyclic word-graph &ndash; a DAWG. Appel and Jacobson,
again, have a good illustration of this reduction.</p>

<p><img src="/images/dawg.png" alt="DAWG" /></p>

<p>In Pythonic style, but mostly to save time and avoid mistakes, I&rsquo;ve chosen to
use <a href="https://pypi.python.org/pypi/DAWG-Python/0.7.2"><em>DAWG-Python</em></a> to manage
storing and access to the dictionary as a DAWG.</p>

<pre><code class="language-python">import dawg

with open('words.txt') as f:
    words = f.read().splitlines()

cdawg = dawg.CompletionDAWG(words)
</code></pre>

<h2 id="finding-solutions">Finding solutions</h2>

<p>With the dictionary stored as a DAWG and the tiles of the board stored as a
graph, solutions can be found by simultaneously performing depth-first search on
the DAWG and from each letter on the board. Due to the rules of Word Streak,
each tile can only be visited once; so, a list of visited tiles needs to be
stored. The possible paths from each tile are therefore to the set of neighbours
of the current tile, subtract the set of visited tiles. If the current string is
a solution, then it will be &lsquo;contained&rsquo; in the DAWG and can be created on the
board in legal moves. If the current string is the prefix of some word
in the DAWG, then the next possible paths can be explored recursively;
determining whether the current word is a prefix in the DAWG only requires
checking whether the last node pointed to by the edges so far has any further
edges leaving it. If the current string is <em>not</em> the prefix of any other words
in the DAWG, then no further recursion is necessary. This structure is the same
as that of depth-first search.</p>

<p>To store the tiles on the board, I&rsquo;ve chosen to use an array created from
reading four sets of input.</p>

<pre><code class="language-python">b = [[]*4]*4

for i in range(4): 
    b[i] = input().lower()
    if len(b[i]) != 4:
        raise ValueError(&quot;Incorrect number of letters in line&quot;)
</code></pre>

<p>To convert the board array into a graph that can be easily explored I chose to
use the standard <em>NetworkX</em> package. Since a board can contain multiple
different tiles with the same letter, I have also given them unique names by
referencing their position on the board. This is necessary, as NetworkX otherwise assumes that the edges are identical.</p>

<pre><code class="language-python">import networkx 

def fmtnode(i, j):
    return (b[i][j], (i,j))

e = []

for i in range(3):
    for j in range(3):
        e += [  (fmtnode(i,j), fmtnode(i, j+1)),
                (fmtnode(i,j), fmtnode(i+1, j+1)),
                (fmtnode(i,j), fmtnode(i+1, j)),
                (fmtnode(i+1,j), fmtnode(i+1, j+1)),
                (fmtnode(i,j+1), fmtnode(i+1, j+1)),
                (fmtnode(i+1,j), fmtnode(i, j+1))]

g = nx.Graph()
g.add_edges_from(e)
</code></pre>

<p>The depth-first search takes a familiar form.</p>

<pre><code class="language-python">def build(ssf, start, visited):
    p = []
    xs = set(g.neighbors(start)).difference(visited)
    if len(xs) == 0:
        return []
    for t,n in xs:
        ns = ssf + t
        if ns in cdawg:
            p += [ns]
        if cdawg.has_keys_with_prefix(ns):
            p += build(ns, (t,n), visited + [(t,n)])
    return p
</code></pre>

<p>The solutions can then be built by changing the start tile from the board.</p>

<pre><code class="language-python">def build(ssf, start, visited):
    p = []
    xs = set(g.neighbors(start)).difference(visited)
    if len(xs) == 0:
        return []
    for t,n in xs:
        ns = ssf + t
        if ns in cdawg:
            p += [ns]
        if cdawg.has_keys_with_prefix(ns):
            p += build(ns, (t,n), visited + [(t,n)])
    return p
</code></pre>

<p>The unique solutions can then be printed, in decreasing order of length.</p>

<pre><code class="language-python">for s in sorted(set(sols), key=len, reverse=True):
    print(s)
</code></pre>

<p>You will notice that this solution doesn&rsquo;t account for letter value, nor positions on the
board that can multiply scores. Despite the false assumption that the longest
word will <em>always</em> produce the highest score, I have maintained the highest
leaderboard position since. I am quite impressed by the speed of the solution,
but have to give Appel and Jacobson credit for that. This small project took a
few hours in total, for both research and implementation and hopefully this
guide and my code reduces that time to a few minutes for others!</p>

<p>The code and dictionary is available <a href="githb">on GitHub</a>, but I&rsquo;ve also
reproduced the code below.</p>

<pre><code class="language-python">import dawg
import networkx as nx

b = [[]*4]*4

for i in range(4): 
    b[i] = input().lower()
    if len(b[i]) != 4:
        raise ValueError(&quot;Incorrect number of letters in line&quot;)

with open('words.txt') as f:
    words = f.read().splitlines()

cdawg = dawg.CompletionDAWG(words)

def fmtnode(i, j):
    return (b[i][j], (i,j))

e = []

for i in range(3):
    for j in range(3):
        e += [  (fmtnode(i,j), fmtnode(i, j+1)),
                (fmtnode(i,j), fmtnode(i+1, j+1)),
                (fmtnode(i,j), fmtnode(i+1, j)),
                (fmtnode(i+1,j), fmtnode(i+1, j+1)),
                (fmtnode(i,j+1), fmtnode(i+1, j+1)),
                (fmtnode(i+1,j), fmtnode(i, j+1))]

g = nx.Graph()
g.add_edges_from(e)

def build(ssf, start, visited):
    p = []
    xs = set(g.neighbors(start)).difference(visited)
    if len(xs) == 0:
        return []
    for t,n in xs:
        ns = ssf + t
        if ns in cdawg:
            p += [ns]
        if cdawg.has_keys_with_prefix(ns):
            p += build(ns, (t,n), visited + [(t,n)])
    return p

sols = []

for i in range(4):
    for j in range(4):
        sols += build(b[i][j], fmtnode(i,j), [fmtnode(i,j)])

for s in sorted(set(sols), key=len, reverse=True):
    print(s)
</code></pre>

    </section>
</article>

<footer id="post-meta" class="clearfix">
    
    <img class="avatar" src="http://jackw.xyz/images/avatar.png">
    <div>
        <span class="dark">Jack Weatherilt</span>
        <span></span>
    </div>
    
    <section id="sharing">
        <a class="twitter" href="https://twitter.com/intent/tweet?text=http%3a%2f%2fjackw.xyz%2fposts%2fwordstreak-solver%2f - Building%20a%20Word%20Streak%20Solver "><span class="icon-twitter"> tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

    </section>
</footer>



<ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        <li>
            <a href="/posts/bitnami-ghost/">Setting up Let&#39;s Encrypt with a Bitnami Ghost image<aside class="dates">Aug 20 2017</aside></a>
        </li>
    
</ul>



        <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://www.github.com/jckw/">
        <i class="fa fa-github"></i>
    </a>
    


</div>

    
    <p class="small">
    
        Copyleft (GNU GPL)
    
    </p>
</footer>

    </section>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="http://jackw.xyz/js/main.js"></script>
<script src="http://jackw.xyz/js/highlight.js"></script>
<script>hljs.initHighlightingOnLoad();</script>





</body>
</html>
